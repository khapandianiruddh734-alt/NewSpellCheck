<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Excel Menu Cleaner</title>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

<style>
body {
  font-family: Arial, sans-serif;
  background: #f4f6f8;
  padding: 20px;
}
.container {
  max-width: 1300px;
  margin: auto;
  background: white;
  padding: 20px;
  border-radius: 10px;
}
button, select, input {
  padding: 8px;
  margin: 5px 0;
}
button {
  background: #2563eb;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}
button:hover { background: #1e40af; }
table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 10px;
  font-size: 13px;
}
th, td {
  border: 1px solid #ddd;
  padding: 6px;
}
th { background: #f1f5f9; }
.flex { display: flex; gap: 20px; }
.half { width: 50%; }
.highlight { background: #fff3cd; }
.approval {
  background: #f9fafb;
  padding: 10px;
  margin-top: 10px;
  border-radius: 6px;
}
</style>
</head>

<body>

<div class="container">
<h2>Upload Excel → Clean → Download</h2>

<input type="file" accept=".xlsx,.csv" onchange="handleFile(event)">
<br>

<select id="columnSelect"></select>
<br>

<button onclick="removeDuplicates()">Remove Duplicates</button>
<button onclick="spellCheck()">Spell Check</button>
<button onclick="downloadExcel()">Download Cleaned File</button>

<div class="flex">
  <div class="half">
    <h3>Input (Original)</h3>
    <table id="inputTable"></table>
  </div>
  <div class="half">
    <h3>Output (Cleaned)</h3>
    <table id="outputTable"></table>
  </div>
</div>

<div id="approvals"></div>
</div>

<script>
let originalData = [];
let cleanedData = [];
let headers = [];
let suggestions = [];
let highlightedIndexes = new Set();

// FOOD DICTIONARY
const foodDictionary = {
  "chiken": "chicken",
  "biriyani": "biryani",
  "coffe": "coffee",
  "frape": "frappe",
  "sandwitch": "sandwich",
  "nudels": "noodles",
  "piza": "pizza"
};

// LOAD FILE
function handleFile(e) {
  const reader = new FileReader();
  reader.onload = evt => {
    const workbook = XLSX.read(new Uint8Array(evt.target.result), { type: "array" });
    const sheet = workbook.Sheets[workbook.SheetNames[0]];

    originalData = XLSX.utils.sheet_to_json(sheet);
    cleanedData = JSON.parse(JSON.stringify(originalData));
    headers = Object.keys(originalData[0]);

    populateColumns();
    renderTables();
  };
  reader.readAsArrayBuffer(e.target.files[0]);
}

// COLUMN DROPDOWN
function populateColumns() {
  const sel = document.getElementById("columnSelect");
  sel.innerHTML = "<option value=''>Select Item Name Column</option>";
  headers.forEach(h => sel.innerHTML += `<option value="${h}">${h}</option>`);
}

// RENDER TABLES
function renderTables() {
  renderTable("inputTable", originalData);
  renderTable("outputTable", cleanedData);
}

function renderTable(id, data) {
  const table = document.getElementById(id);
  table.innerHTML = "";

  const tr = document.createElement("tr");
  headers.forEach(h => {
    const th = document.createElement("th");
    th.textContent = h;
    tr.appendChild(th);
  });
  table.appendChild(tr);

  data.slice(0, 10).forEach((row, i) => {
    const tr = document.createElement("tr");

    if (id === "outputTable" && highlightedIndexes.has(i)) {
      tr.classList.add("highlight");
    }

    headers.forEach(h => {
      const td = document.createElement("td");
      td.textContent = row[h];
      tr.appendChild(td);
    });
    table.appendChild(tr);
  });
}

// DUPLICATE REMOVER (SMART LOGIC)
function removeDuplicates() {
  const nameCol = columnSelect.value;
  if (!nameCol) return alert("Select Item Name column");

  const priceCol = "Price"; // must match Excel header
  highlightedIndexes.clear();

  const groups = {};
  cleanedData.forEach((row, idx) => {
    const key = row[nameCol]?.toLowerCase().trim();
    if (!groups[key]) groups[key] = [];
    groups[key].push({ row, idx });
  });

  const finalData = [];

  Object.values(groups).forEach(items => {
    if (items.length === 1) {
      finalData.push(items[0]);
      return;
    }

    const priceMap = {};
    items.forEach(it => {
      const p = it.row[priceCol];
      if (!priceMap[p]) priceMap[p] = [];
      priceMap[p].push(it);
    });

    const prices = Object.keys(priceMap);

    if (prices.length > 1) {
      prices.forEach(p => {
        priceMap[p].forEach(it => {
          highlightedIndexes.add(finalData.length);
          finalData.push(it);
        });
      });
    } else {
      finalData.push(items[0]);
    }
  });

  cleanedData = finalData.map(r => r.row);
  renderTables();
}

// SPELL CHECK (WORD BY WORD)
async function spellCheck() {
  const col = columnSelect.value;
  if (!col) return alert("Select Item Name column");

  suggestions = [];
  document.getElementById("approvals").innerHTML = "";

  for (let i = 0; i < cleanedData.length; i++) {
    let text = cleanedData[i][col];
    if (!text) continue;

    let words = text.split(" ");
    let corrected = [...words];
    let changed = false;

    for (let w = 0; w < words.length; w++) {
      let cleanWord = words[w].toLowerCase().replace(/[^a-z]/g, "");
      if (foodDictionary[cleanWord]) {
        corrected[w] = foodDictionary[cleanWord];
        changed = true;
      }
    }

    if (changed) {
      suggestions.push({
        index: i,
        column: col,
        from: text,
        to: corrected.join(" ")
      });
    }
  }

  if (suggestions.length === 0) {
    document.getElementById("approvals").innerHTML =
      "<b>No spelling mistakes found</b>";
    return;
  }

  renderApprovals();
}

// APPROVAL UI
function renderApprovals() {
  const div = document.getElementById("approvals");
  div.innerHTML = "<h3>Approve Spelling Corrections</h3>";

  suggestions.forEach(s => {
    div.innerHTML += `
      <div class="approval">
        <b>${s.from}</b><br>
        ➜ <span style="color:green">${s.to}</span><br>
        <button onclick="approve(${s.index}, '${s.column}', \`${s.to}\`)">
          Apply
        </button>
      </div>
    `;
  });
}

function approve(i, col, val) {
  cleanedData[i][col] = val;
  renderTables();
}

// DOWNLOAD
function downloadExcel() {
  const ws = XLSX.utils.json_to_sheet(cleanedData);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, "Cleaned");
  XLSX.writeFile(wb, "cleaned_data.xlsx");
}
</script>

</body>
</html>
